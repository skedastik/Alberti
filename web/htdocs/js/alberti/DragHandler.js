/*  
 *  Copyright (C) 2011, Alaric Holloway <alaric.holloway@gmail.com>
 *  
 *  This file is part of Alberti.
 *
 *  Alberti is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Alberti is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Alberti.  If not, see <http://www.gnu.org/licenses/>.
 *  
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * DragHandler.js
 * extends EventHandler
 * 
 * A specialized EventListener interface for draggable objects.
 * 
 * USAGE
 * 
 * For an inheriting object to begin "listening" for drag events, you need
 * to register the object as an event listener for "mousedown" events (via
 * addEventListener()). Further, the inheriting class must implement 
 * DragHandler's abstract onDrag method, the arguments of which contain a
 * pair of integers (dx,dy) describing the drag vector in pixels since the
 * last mouse-move event. The onDragBegin and onDrop methods may be
 * implemented optionally.
 * 
 * The constructor's 'dragThreshold' argument is optional and specifies the
 * minimum drag distance before the onDragBegin method should be invoked.
 * 
 * NOTE
 * 
 * This is entirely separate and distinct from HTML5 drag and drop
 * functionality.
 * 
 * * */
 
function DragHandler(dragThreshold) {
	DragHandler.baseConstructor.call(this);
	this.lastX = 0;
	this.lastY = 0;
	this.startX = 0;
	this.startY = 0;
	this.currentlyDragging = false;
	this.dragThreshold = (dragThreshold !== undefined) ? dragThreshold : 0;
}
Util.extend(DragHandler, EventHandler);

// If dragging is currently taking place, DragHandler::cancelDrag cancels
// dragging, immediately invoking the instance's onDrop method. Otherwise has
// no effect.
DragHandler.prototype.cancelDrag = function(evt) {
	if (this.currentlyDragging) {
		this.currentlyDragging = false;
		this.onDrop(evt);
	}
	
	this.unregisterListener("mousemove", window, true);
	this.unregisterListener("mouseup", window, true);
};

DragHandler.prototype.mousedown = function(evt) {
	this.lastX = this.startX = evt.clientX;
	this.lastY = this.startY = evt.clientY;

	// Now that the mouse is down, start capturing mousemove and mouseup events
	this.registerListener("mousemove", window, true);
	this.registerListener("mouseup", window, true);
};

DragHandler.prototype.mousemove = function(evt) {
	if (!this.currentlyDragging) {
		if (Math.abs(evt.clientX - this.startX) > this.dragThreshold
			|| Math.abs(evt.clientY - this.startY) > this.dragThreshold
		) {
			// Only begin dragging when mouse has moved beyond drag threshold
			this.currentlyDragging = true;
			this.onDragBegin(evt);
		}
	} else {
		this.onDrag(evt.clientX - this.lastX, evt.clientY - this.lastY, evt);
	}
	
	this.lastX = evt.clientX;
	this.lastY = evt.clientY;
};

DragHandler.prototype.mouseup = function(evt) {
	// Now that dragging has stopped, stop capturing mouse events
	this.cancelDrag(evt);
};

// evt is the event object generated by the mousedown event.
DragHandler.prototype.onDragBegin = function(evt) {};

// Abstract: Must be implemented by inheriting class. (x,y) describe the drag 
// vector, in pixels, since the last mouse move event. evt is the event object
// generated by the mousemove event.
DragHandler.prototype.onDrag = function(dx, dy, evt) {
	this.cancelDrag(evt);
	throw "Abstract method DragHandler::onDrag not implemented by inheriting class!";
};

// evt is the event object generated by the mouseup event.
DragHandler.prototype.onDrop = function(evt) {};
