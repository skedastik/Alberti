/*
 * DragHandler.js
 * extends EventHandler
 * 
 * A specialized EventListener interface for draggable objects.
 * 
 * USAGE
 * 
 * For an inheriting object to begin "listening" for drag events, you need
 * to register the object as an event listener for "mousedown" events (via
 * addEventListener()). Further, the inheriting class must implement 
 * DragHandler's abstract onDrag method, the arguments of which contain a
 * pair of integers (dx,dy) describing the drag vector in pixels since the
 * last mouse-move event. The onDragBegin and onDrop methods may be
 * implemented optionally.
 * 
 * The constructor's 'dragThreshold' argument is optional and specifies the
 * minimum drag distance before the onDragBegin method should be invoked.
 * 
 * NOTE
 * 
 * This is entirely separate and distinct from HTML5 drag and drop
 * functionality.
 * 
 * * */
 
function DragHandler(dragThreshold) {
	DragHandler.baseConstructor.call(this);
	this.lastX = 0;
	this.lastY = 0;
	this.startX = 0;
	this.startY = 0;
	this.currentlyDragging = false;
	this.dragThreshold = (dragThreshold !== undefined) ? dragThreshold : 0;
}
Util.extend(DragHandler, EventHandler);

// If dragging is currently taking place, DragHandler::cancelDrag cancels
// dragging, immediately invoking the instance's onDrop method. Otherwise has
// no effect.
DragHandler.prototype.cancelDrag = function(evt) {
	if (this.currentlyDragging) {
		this.currentlyDragging = false;
		this.onDrop(evt);
	}
	
	window.removeEventListener("mousemove", this, true);
	window.removeEventListener("mouseup", this, true);
};

DragHandler.prototype.mousedown = function(evt) {
	this.lastX = this.startX = evt.clientX;
	this.lastY = this.startY = evt.clientY;

	// Now that the mouse is down, start capturing mousemove and mouseup events
	window.addEventListener("mousemove", this, true);
	window.addEventListener("mouseup", this, true);
};

DragHandler.prototype.mousemove = function(evt) {
	if (!this.currentlyDragging) {
		if (Math.abs(evt.clientX - this.startX) > this.dragThreshold
			|| Math.abs(evt.clientY - this.startY) > this.dragThreshold
		) {
			// Only begin dragging when mouse has moved beyond drag threshold
			this.currentlyDragging = true;
			this.onDragBegin(evt);
		}
	} else {
		this.onDrag(evt.clientX - this.lastX, evt.clientY - this.lastY, evt);
	}
	
	this.lastX = evt.clientX;
	this.lastY = evt.clientY;
};

DragHandler.prototype.mouseup = function(evt) {
	// Now that dragging has stopped, stop capturing mouse events
	this.cancelDrag(evt);
};

// evt is the event object generated by the mousedown event.
DragHandler.prototype.onDragBegin = function(evt) {};

// Abstract: Must be implemented by inheriting class. (x,y) describe the drag 
// vector, in pixels, since the last mouse move event. evt is the event object
// generated by the mousemove event.
DragHandler.prototype.onDrag = function(dx, dy, evt) {
	this.cancelDrag(evt);
	throw "Abstract method DragHandler::onDrag not implemented by inheriting class!";
};

// evt is the event object generated by the mouseup event.
DragHandler.prototype.onDrop = function(evt) {};
